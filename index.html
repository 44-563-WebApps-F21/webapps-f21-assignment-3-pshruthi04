<!DOCTYPE html>
<html>
<head>
<title>Lab 02</title>
</head>
<body>
<header>
<h1>Shruthi patkur</h1>
</header>
<h6>Hyderabad</h6>
<p>Largest city of the Indian state of Telangana<b>It was known for pearl industry</b>It's a home to many upscale restaurants and shops.</p>
<br>
<img src="hyd.png" alt=" Image ">
<hr>
<h2>Directions from Maryville to hyderabad</h2>
<ol>
<li>Reach Kansas Airport(MCI)</li>
<li>Take a flight to Chicago(ORD)</li>
<li>From Chicago, take a direct flight to Hyderabad</li>
</ol>
<ul>
    <li>clothing</li>
    <li>snacks</li>
    <li>headphones</li>
    <li>fully charged mobile phone</li>
</ul>
<a href="aboutme.html">Redirect to AboutMe file</a>
<style>
    table{
        border-collapse:collapse;
        width: 20%;
    }
    td,th{
        border: 1px solid black;
        text-align:left;
        padding: 4px;
    }
</style>
<h2>Table</h2>
<table>
    <tr>
      <th>Food/drink item</th>
      <th>Location</th>
      <th>Cost</th>
    </tr>
    <tr>
      <td>Special Chicken Biryani</td>
      <td>Mehfil</td>
      <td>250</td>
    </tr>
    <tr>
      <td>American Chopsy</td>
      <td>Nanking</td>
      <td>220</td>
    </tr>
    <tr>
        <td>butter chicken</td>
        <td>Astoria</td>
        <td>150</td>
      </tr>
  </table>
  <hr>Dynamic Programming</hr>
  <blockquote>Dynamic programming is both a mathematical optimization method and a computer programming method. The method was developed by Richard Bellman in the 1950s and has found applications in numerous fields, from aerospace engineering to economics.</blockquote>
<a href="https://en.wikipedia.org/wiki/Dynamic_programming">page that is directing to wiki</a>
    <pre>
        int m, n;
vector<long long> dp_before(n), dp_cur(n);

long long C(int i, int j);

// compute dp_cur[l], ... dp_cur[r] (inclusive)
void compute(int l, int r, int optl, int optr) {
    if (l > r)
        return;

    int mid = (l + r) >> 1;
    pair<long long, int> best = {LLONG_MAX, -1};

    for (int k = optl; k <= min(mid, optr); k++) {
        best = min(best, {(k ? dp_before[k - 1] : 0) + C(k, mid), k});
    }

    dp_cur[mid] = best.first;
    int opt = best.second;

    compute(l, mid - 1, optl, opt);
    compute(mid + 1, r, opt, optr);
}

int solve() {
    for (int i = 0; i < n; i++)
        dp_before[i] = C(0, i);

    for (int i = 1; i < m; i++) {
        compute(0, n - 1, 0, n - 1);
        dp_before = dp_cur;
    }

    return dp_before[n - 1];
}
    </pre>
  </body>

</html>
